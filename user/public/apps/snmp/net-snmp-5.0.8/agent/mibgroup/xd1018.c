/*
 * Note: this file originally generated by curry
 *        Base on vd168.c, v0.1 2013/06/21 20:04:58 
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include <net-snmp/library/snmp_assert.h>
#include <stdlib.h>
#include <stdio.h>
#include <unistd.h>
#include "util_funcs.h"
#include "utility.h"
#include "sal/sal_system_info.h"
#include "sal/sal_nat_table.h"
#include "sal/sal_voip.h"
#ifdef CONFIG_SUPPORT_DSL
#include "dsl/dsl_common.h"
#endif
#include "xd1018.h"
/****************************************************************************
*                                Defines                                    *
****************************************************************************/
#define SNMP_OID_XD1018 SNMP_OID_ENTERPRISES, 10171, 2, 1, 1, 1, 1, 1, 1
#ifndef u_char
  typedef unsigned char u_char;
#endif

/****************************************************************************
*                            Private Variables                              *
****************************************************************************/

/****************************************************************************
*                            Private Functions                              *
****************************************************************************/
void loadVar_xd1018(struct variable *vp);

//#define DEBUG
#ifdef DEBUG
#include <stdarg.h>
#include <time.h>
#include <sys/time.h>
int mybug(const char *format, ...)
{
    char buf[1024]="";
    va_list arg;
    FILE *fp;
    va_start(arg, format);
    vsnprintf(buf,1024, format, arg);
    va_end(arg);
    fp=fopen("/tmp/snmp_private.log","a");
    if(fp==NULL)
        return 1;
    fwrite(buf,1024,1,fp);
    fclose(fp);
    usleep(1);
    return 0;
}
#else
int mybug(const char *format, ...)
{
	return 0;
}
#endif


/*
 * xd1018_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

oid             xd1018_variables_oid[] = { SNMP_OID_XD1018 };

/*
 * variable1 xd1018_variables:
 *   this variable defines function callbacks and type return information 
 *   for the  mib section 
 */

struct variable1 xd1018_variables[] = {
    /*
     * magic number        , variable type , ro/rw , callback fn  , L(L = length of the oidsuffix), oidsuffix 
     */
#define CPUUTILIZATION		1
    {CPUUTILIZATION, ASN_OCTET_STR, RONLY, var_xd1018, 1, {1}},
#define MEMUSED		11
    {MEMUSED, ASN_OCTET_STR, RONLY, var_xd1018, 1, {2}},
#define NAT_ACTIVE_CONNECTIONS	31
    {NAT_ACTIVE_CONNECTIONS, ASN_GAUGE, RONLY, var_xd1018, 1, {3}},
#define VOICE_STATUS	51
    {VOICE_STATUS, ASN_OCTET_STR, RONLY, var_xd1018, 1, {4}},
#define FXS1_STATUS    71
    {FXS1_STATUS, ASN_OCTET_STR, RONLY, var_xd1018, 1, {5}},
#define FXS2_STATUS 	81
    {FXS2_STATUS, ASN_OCTET_STR, RONLY, var_xd1018, 1, {6}},
#define SIGNALTONOISERATIO_DOWN	91
    {SIGNALTONOISERATIO_DOWN, ASN_OCTET_STR, RONLY, var_xd1018, 1, {8}},
#define SIGNALTONOISERATIO_UP	92
    {SIGNALTONOISERATIO_UP, ASN_OCTET_STR, RONLY, var_xd1018, 1, {9}},
#define LINEATTENUATION_DOWN	95
    {LINEATTENUATION_DOWN, ASN_OCTET_STR, RONLY, var_xd1018, 1, {10}},
#define LINEATTENUATION_UP	96
    {LINEATTENUATION_UP, ASN_OCTET_STR, RONLY, var_xd1018, 1, {11}},
};

/*
 *  
 */


/** Initializes the ap101na module */
void
init_xd1018(void)
{

#ifdef DEBUG
    struct timeval now;
    gettimeofday(&now, (struct timezone *) 0);
#endif
    /*
     * register ourselves with the agent to handle our mib tree 
     */
    REGISTER_MIB(PRODUCT_TYPE, xd1018_variables, variable1,
                 xd1018_variables_oid);

    /*
     * place any other initialization junk you need here
     */
}

/*
 * var_xd1018():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char  *
var_xd1018(struct variable *vp,
            oid * name,
            size_t * length,
            int exact, size_t * var_len, WriteMethod ** write_method)
{
    if (header_generic(vp, name, length, exact, var_len, write_method)
        == MATCH_FAILED)
        return NULL;
    loadVar_xd1018(vp);

    /*
     * this is where we do the value assignments for the mib results.
     */
    switch (vp->magic) {
    case CPUUTILIZATION:
        *var_len = strlen(ap->cpuutilization);
        return (u_char *) &(ap->cpuutilization);
    case MEMUSED:
        *var_len = strlen(ap->memused);
        return (u_char *) &(ap->memused);
    case NAT_ACTIVE_CONNECTIONS:
        *var_len = sizeof(int);
        return (u_char *) &(ap->nat_active);
    case VOICE_STATUS:
        *var_len = strlen(ap->voice_status);
        return (u_char *) &(ap->voice_status);
    case FXS1_STATUS:
        *var_len = strlen(ap->fxs1_status);
        return (u_char *) &(ap->fxs1_status);
    case FXS2_STATUS:
        *var_len = strlen(ap->fxs2_status);
        return (u_char *) &(ap->fxs2_status);
    case SIGNALTONOISERATIO_DOWN:
        *var_len = strlen(ap->signaltonoise_ratio_down);
        return (u_char *) &(ap->signaltonoise_ratio_down);
    case SIGNALTONOISERATIO_UP:
        *var_len = strlen(ap->signaltonoise_ratio_up);
        return (u_char *) &(ap->signaltonoise_ratio_up);
    case LINEATTENUATION_DOWN:
        *var_len = strlen(ap->lineattenuation_down);
        return (u_char *) &(ap->lineattenuation_down);
    case LINEATTENUATION_UP:
        *var_len = strlen(ap->lineattenuation_up);
        return (u_char *) &(ap->lineattenuation_up);
    default:
        ERROR_MSG("");
    }
    return NULL;
}



/****************************************************************************
*                                                                           *
*                      loadVar_ap101na() - Load the Var_ap101na             *
*                                                                           *
****************************************************************************/
void loadVar_xd1018(struct variable *vp)
{
    //var_xd1018 	
#ifdef DEBUG
    struct timeval now;
#endif
    struct sta_nat_conntrack sta; 
    switch (vp->magic) {
    //cpustatus
    case CPUUTILIZATION:
        *nap.cpuutilization = '\0';
        sprintf(nap.cpuutilization, "%5.2f%%", sal_get_cpu_utilization(1));
        break;
    //meminfo
    case MEMUSED:
        *nap.memused = '\0';
        sprintf(nap.memused, "%5.2f%%", sal_get_mem_utilization());
#ifdef DEBUG
        gettimeofday(&now, (struct timezone *) 0);
        mybug("%lu:%lu:xd1018,meminfo!<%s>\n",(unsigned long)now.tv_sec,(unsigned long)now.tv_usec, nap.memused);
#endif
        break;
    //NAT
    case NAT_ACTIVE_CONNECTIONS:
        get_nattable_statistic(&sta);
        nap.nat_active = sta.used;
        break;
    //voice status
    case VOICE_STATUS:
        *nap.voice_status = '\0';
        strncpy(nap.voice_status, sal_voip_get_reg_state_t(1), sizeof(nap.voice_status));
        break;	
    //phone status(FXS1)
    case FXS1_STATUS:
        *nap.fxs1_status = '\0';
        sprintf(nap.fxs1_status, "%s", sal_voip_get_call_state_t(1));
        break;
    //phone status(FXS2)
    case FXS2_STATUS:
        *nap.fxs2_status = '\0';
        sprintf(nap.fxs2_status, "%s", sal_voip_get_call_state_t(2));
        break;

    //signal to noise
    case SIGNALTONOISERATIO_DOWN:
        *nap.signaltonoise_ratio_down = '\0';
#ifdef CONFIG_SUPPORT_DSL
        sprintf(nap.signaltonoise_ratio_down, "%s", val_get_dsl_DownNoise());
#endif
        break;
    case SIGNALTONOISERATIO_UP:
        *nap.signaltonoise_ratio_up = '\0';
#ifdef CONFIG_SUPPORT_DSL
        sprintf(nap.signaltonoise_ratio_up, "%s", val_get_dsl_UpNoise());
#endif
        break;
    //lineattenuation
    case LINEATTENUATION_DOWN:
        *nap.lineattenuation_down = '\0';
#ifdef CONFIG_SUPPORT_DSL
        sprintf(nap.lineattenuation_down, "%s", val_get_dsl_DownAttenuation());
#endif
        break;
    case LINEATTENUATION_UP:
        *nap.lineattenuation_up = '\0';
#ifdef CONFIG_SUPPORT_DSL
        sprintf(nap.lineattenuation_up, "%s", val_get_dsl_UpAttenuation());
#endif
        break;
    default:
        ERROR_MSG("nothing to be loaded!\n");
	}
}

